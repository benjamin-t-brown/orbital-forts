(()=>{function e(e){let t={"&":"&amp;",'"':"&quot;","<":"&lt;",">":"&gt;"};return e.replace(/[&"<>]/g,e=>t[e])}const t={},a=e=>e[0].id,n=e=>e[2],r=(e,t)=>e[2]=t,s=e=>e[1],o=(e,t)=>e[1]=t,i=e=>e[1]=null,l=e=>"No game for user: "+n(e),c=(e,t)=>[e,t],d=(e,t)=>JSON.stringify([e,t]),p=e=>async(t,a)=>{try{await e(t,a)}catch(e){console.error("ERROR",e.stack),a.send(d(null,"Error."))}},u=()=>{const e=[],a=t=>{for(let a=0;a<e.length;a++)if(e[a].id===t)return!0};for(const n in t){const r=s(t[n]);r&&(a(r.id)||e.push(r))}return e},m=()=>u().filter(e=>!e.isStarted()&&!e.isPractice()&&e.getPlayers().length<4),y=()=>{((e,a,n)=>{for(const n in t){if(void 0===n)continue;const[r]=t[n];r.emit(e,a)}})(G_S_LIST_UPDATED,c(m()))},g=(e,a,n)=>{const r=(e=>t[e])(e);return r?(e=>e[3])(r)!==a.headers.key?(n.send(d(null,"Unauthorized (invalid key): id="+e)),!1):r:(n.send(d(null,"No user: id="+e)),!1)},_=e=>{const[a,n]=e;n&&n.leave(e),delete t[a]},h={[G_R_CREATE+"/:id/:userName/:initialMapIndex/:isPractice"]:p(async(t,a)=>{let{id:i,userName:l,initialMapIndex:c,isPractice:p}=t.params;const m=g(i,t,a);if(!m)return;if(!l)return void a.send(d(null,"No given userName."));if(l.length>10)return void a.send(d(null,"Username too long."));if(c=parseInt(c),(!c||isNaN(c)||c<0)&&(c=0),l=e(l),s(m))return void a.send(d(null,(e=>"User in another game: "+n(e))(m)));if(u().length>=10)return void a.send(d(null,(e=>"Max games supported exceeded: "+n(e))(m)));r(m,l);const _=l+"'s Game",h=M(m,_);o(m,h),await h.setMapIndex(c),"true"===p&&await h.setPractice(),a.send(d({id:h.id,name:_,lobbyData:h.getLobbyData()})),y()}),[G_R_UPDATE_LOBBY+"/:id/:args"]:p(async(e,t)=>{const{id:a,args:n}=e.params,[r]=n.split(","),o=g(a,e,t);if(!o)return;const i=s(o);i?(await i.setMapIndex(r),i.updateLobbyData(),t.send(d({id:i.id,name:i.name,lobbyData:i.getLobbyData()}))):t.send(d(null,l(o)))}),[G_R_JOIN+"/:id/:args"]:p(async(t,a)=>{const{id:s,args:i}=t.params,c=i.indexOf(","),p=i.slice(0,c);let m=i.slice(c+1);const _=g(s,t,a);if(!_)return;if(m.length>10)return void a.send(d(null,"Username too long."));m=e(m||"");const h=(e=>u().reduce((t,a)=>a.id===e?a:t,null))(p);h?(o(_,h),r(_,m),n(_),await h.join(_)?(a.send(d({id:h.id,name:h.name,lobbyData:h.getLobbyData()})),y()):a.send(d(null,"Cannot join."))):a.send(d(null,l(_)))}),[G_R_LEAVE+"/:id"]:p((e,t)=>{const{id:a}=e.params,r=g(a,e,t);if(!r)return;const o=s(r);o?(n(r),i(r),o.leave(r),t.send(d(o.id)),y()):t.send(d(null,l(r)))}),[G_R_START+"/:id/:mapIndex"]:p(async(e,t)=>{const{id:a,mapIndex:r}=e.params,o=g(a,e,t);if(!o)return;const i=s(o);i?i.canStart()?(n(o),t.send(d(!0)),await i.setMapIndex(+r),await i.start(),y()):t.send(d(null,"Cannot start yet.")):t.send(d(null,l(o)))}),[G_R_CONFIRM_ACTION+"/:id/:action/:args"]:p((e,t)=>{const{id:a,action:r,args:o}=e.params,i=g(a,e,t);if(!i)return;const c=s(i);c?c.isStarted()?c.confirmAction(r,o,i)?(n(i),t.send(d(!0))):t.send(d(null,"Cannot confirm.")):t.send(d(null,"Game not started.")):t.send(d(null,l(i)))}),io:async e=>{const a=G_randomId(),n=((e,t)=>[e,"","",t])(e,a);t[e.id]=n,e.on("disconnect",p(()=>{_(n)})),e.on("error",p(()=>{_(n)})),e.on("socket-error",p(()=>{_(n)}));const r=await f();e.emit(G_S_CONNECTED,c({games:m(),maps:r.map(e=>({name:e.name})),id:e.id,key:a}))}};module.exports=h;const f=async()=>await storage.get("maps");let G=0;const E=async()=>{if(0===G){const e=await f();G=e.length}return G},M=(e,t)=>{let r,s,o,l,d=[e],p=0,u=0,m=!1,g=!1,_=null,h=0,G=Math.round(50/G_FRAME_MS),M=Math.round(50/G_FRAME_MS),v=0,b=0,R=25/G_SCALE,x=175,P=0,F=null,L=null;const O=["blue","red","green","yellow"],C=()=>{try{let e=+new Date;s=e-r,r=e,u=r-p,_.tss=u,G_simulate(_,{startTime:p,nowDt:s,now:r,timeSinceStart:u});let{projectiles:t,shockwaves:a}=_;if(0===t.length&&0===a.length)return void j();v++,v>=G&&(((e,t)=>{const a=D(t);a.i=e,V.emitAll(G_S_BROADCAST,c({i:e,timestamp:u,dynamicGameData:a}))})(h++,_),v=0),b++,b>=M&&(b=0,I(F,r-p,_))}catch(e){console.error("error running simulation",e),j()}},k=()=>{p=r=+new Date,s=0,h=0,V.emitAll(G_S_START_SIMULATION,c(A(_))),l=setTimeout(j,2e4),o=setInterval(C,G_FRAME_MS)},j=()=>{try{if(m){const e=D(_);V.emitAll(G_S_STOP_SIMULATION,c({i:-1,timestamp:r-p,dynamicGameData:e})),I(F,r-p,_),clearInterval(o),o=-1,clearTimeout(l),l=-1,_.projectiles.forEach(e=>{delete _.entMap[e]}),_.shockwaves.forEach(e=>{delete _.entMap[e]}),_.shockwaves=[],_.projectiles=[],_.collisions=[];const t=B();t?(V.finished=!0,V.finish(t)):(_.players.forEach(e=>{const t=G_getEntityFromEntMap(e,_);t.ready=!1,t.funds+=10}),z(),w(F,_))}}catch(e){console.error("Error stopping game",e.stack)}},U=()=>_.players.reduce((e,t)=>{const a=G_getEntityFromEntMap(t,_);return e&&(!!a.dead||a.ready)},!0),B=()=>{if(g)return!1;let e=[];for(let t=0;t<_.players.length;t++){const a=G_getEntityFromEntMap(_.players[t],_);a.dead||e.push(a)}return 0===e.length?"draw":1===e.length&&e[0].id},J=()=>{V.emitAll(G_S_LOBBY_DATA,c(V.getLobbyData()))},z=()=>{V.emitAll(G_S_GAME_METADATA,c(V.getGameMetadata()))},V={id:a(e),name:t,getPlayers:()=>d.map(e=>({id:a(e),userName:n(e)})),getLobbyData:()=>({mapIndex:P,ownerId:a(e),players:V.getPlayers()}),getGameMetadata:()=>({playersNotReady:_.players.map(e=>G_getEntityFromEntMap(e,_)).filter(e=>!e.dead&&!e.ready).map(e=>({playerName:e.name,color:e.color})),timer:30}),updateLobbyData:J,updateGameMetadata:z,join:async e=>m||g?(console.error("Cannot join"),!1):d.length<4&&(d.push(e),J(),!0),leave(e){for(let t=0;t<d.length;t++){const n=d[t];if(n===e){if(d.splice(t,1),i(n),m){const e=G_getEntityFromEntMap(a(n),_);return 0===d.length?V.stop():e.dead||(e.dead=!0),B()?V.stop():U()&&setTimeout(()=>{try{k()}catch(e){console.error("Error starting",e.stack)}},500),!0}return 0===t?V.stop():J(),!0}}return!1},async start(){m=!0;const e=await f();_=((e,r)=>{let s=(e=>{let t=e.length;e=[...e];const a=[];for(let n=0;n<t;n++){const t=Math.floor(Math.random()*e.length);a.push(e[t]),e.splice(t,1)}return a})(e);L=r;const{width:o,height:i,playerLocations:l}=L,c={name:t,mode:G_MODES.standard,mapName:L.name,width:o,height:i,mapIndex:P,entMap:{},collisions:[],players:[],planets:[],resources:[],projectiles:[],fields:[],shockwaves:[],result:!1,baseFundsPerRound:10,maxRoundLength:1e4};for(let e=0;e<s.length;e++){const t=s[e],{x:r,y:o,r:i}=l[e],d=G_getRandomLocInCircle(r,o,i);let p={};if(c.mode===G_MODES.standard)for(let e in G_actions)p[G_actions[e][0]]=e<=1?99:0;const u={id:a(t),name:n(t),funds:x,actions:p,ready:!1,dead:!1,hp:1,color:O[e],r:R,...d,target:[d.x,d.y]};c.entMap[u.id]=u,c.players.push(u.id)}return G_createEntities(c,L,{}),c})(d,e[P]),_.isPractice=g,F=S(_),w(F,_),V.emitAll(G_S_START,c({startTime:p,gameData:A(_)})),z()},stop(){j(),V.emitAll(G_S_STOP,c("The game was stopped.")),d.forEach(e=>{i(e)}),y()},finish(e){_.result=e,F.result=e,V.emitAll(G_S_FINISHED,c({gameData:_,replay:F})),d.forEach(e=>{i(e)}),y(),g||N(F)},setPractice(){g=!0,x=1e5},async setMapIndex(e){const t=await E();e>=0&&e<t&&(P=e)},confirmAction(e,t,n){const r=G_getEntityFromEntMap(a(n),_);if(!r||r.dead)return console.error("No player exists in game or player is dead.",a(n)),!1;if(r.ready)return console.error("Player has already confirmed an action.",a(n)),!1;const[s,o,i,l]=t.split(","),c=G_getNormalizedVec([s-r.x,o-r.y]),d=G_SPEEDS[i]&&G_SPEEDS[i][0]||G_SPEEDS.normal[0],p=((e,t,a)=>{const n=G_getActionCost(e)+G_getSpeedCost(t);return G_getEntityFromEntMap(a,_).funds>n&&n})(e,i,a(n));if(!1===p)return!1;let u=null;try{u=JSON.parse(l)}catch(e){return!1}const m={action:e,speed:d,vec:c,target:[s,o],auxArgs:u,cost:p};return T(F,r,m),_.tss=0,G_applyAction(_,r,m),r.ready=!0,U()&&setTimeout(()=>{try{k()}catch(e){console.error("Error starting",e.stack)}},500),z(),!0},canStart:()=>!!g||d.length>1&&d.length<=4&&!m,isPractice:()=>g,isStarted:()=>m,getReplay:()=>F,emitAll(e,t){d.forEach(a=>{const[n]=a;n.emit(e,t)})}};return V},S=e=>{const t={version:2.1};return t.id=G_randomId(),t.date=+new Date,t.name=e.name,t.mapName=e.mapName,t.mode=e.mode,t.initialGameData=A(e),t.rounds=[],t.result=null,t},A=e=>{const t={};for(let a in e.entMap)t[a]=b(e.entMap[a]);return{...e,entMap:t,collisions:e.collisions.map(v),fields:e.fields.slice(),planets:e.planets.slice(),players:e.players.slice(),resources:e.resources.slice(),projectiles:e.projectiles.slice()}},D=e=>{const t={};return e.players.forEach(a=>{t[a]=b(G_getEntityFromEntMap(a,e))}),e.projectiles.forEach(a=>{t[a]=b(G_getEntityFromEntMap(a,e))}),e.shockwaves.forEach(a=>{G_getEntityFromEntMap(a,e).sent||(a.sent=!0,t[a]=b(G_getEntityFromEntMap(a,e)))}),{partialEntMap:t,collisions:e.collisions.map(v),fields:e.fields.slice(),planets:e.planets.slice(),players:e.players.slice(),resources:e.resources.slice(),projectiles:e.projectiles.slice()}},w=(e,t)=>{e.rounds.push({roundNumber:e.rounds.length,dynamicGameData:D(t),actions:{},snapshots:[]})},T=(e,t,{action:a,speed:n,vec:r,cost:s,target:o})=>{e.rounds[e.rounds.length-1].actions[t.id]={action:a,speed:n,vec:r,cost:s,target:o}},I=(e,t,a)=>{e.rounds[e.rounds.length-1].snapshots.push({timestamp:t,dynamicGameData:D(a)})},N=async e=>{try{let t=await storage.get("replays");t||(t=[]),t.length>10&&(t=t.slice(-9)),t.push(e),await storage.set("replays",t)}catch(e){console.error("error saving replay",e.stack)}},v=e=>{const[t,a,n,r]=e||[];return[t,a,n,r]},b=e=>{switch(G_getEntityType(e)){case G_entity.player:return a=e,{...a,actions:{...a.actions}};case G_entity.projectile:case G_entity.planet:return(e=>{const t={...e,meta:{...e.meta}};return delete t.satCircle,delete t.update,t})(e);default:return(e=>[G_entity.wall].includes(e.type))(e)?(e=>{const t={...e};return delete t.satBox,t})(e):(e=>[G_entity.proximityShockwave].includes(e.type))(e)?(e=>{const t={...e};return delete t.satCircle,delete t.sent,t})(e):(t=e,{...t})}var t,a}})();