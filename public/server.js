(()=>{function e(e){let t={"&":"&amp;",'"':"&quot;","<":"&lt;",">":"&gt;"};return e.replace(/[&"<>]/g,e=>t[e])}const t={},a=e=>e[0].id,n=e=>e[2],r=(e,t)=>e[2]=t,s=e=>e[1],o=(e,t)=>e[1]=t,i=e=>e[1]=null,l=e=>"No game for user: "+n(e),c=(e,t)=>[e,t],d=(e,t)=>JSON.stringify([e,t]),m=e=>async(t,a)=>{try{await e(t,a)}catch(e){console.error("ERROR",e.stack),a.send(d(null,"Error."))}},u=()=>{const e=[],a=t=>{for(let a=0;a<e.length;a++)if(e[a].id===t)return!0};for(const n in t){const r=s(t[n]);r&&(a(r.id)||e.push(r))}return e},p=()=>u().filter(e=>!e.isStarted()&&!e.isPractice()&&e.getPlayers().length<4),y=()=>{((e,a,n)=>{for(const n in t){if(void 0===n)continue;const[r]=t[n];r.emit(e,a)}})(G_S_LIST_UPDATED,c(p()))},g=(e,a,n)=>{const r=(e=>t[e])(e);return r?(e=>e[3])(r)!==a.headers.key?(n.send(d(null,"Unauthorized (invalid key): id="+e)),!1):r:(n.send(d(null,"No user: id="+e)),!1)},_={[G_R_CREATE+"/:id/:userName/:isPractice"]:m(async(t,a)=>{let{id:i,userName:l,isPractice:c}=t.params;const m=g(i,t,a);if(!m)return;if(!l)return void a.send(d(null,"No given userName."));if(l.length>10)return void a.send(d(null,"Username too long."));if(l=e(l),s(m))return void a.send(d(null,(e=>"User in another game: "+n(e))(m)));if(u().length>=10)return void a.send(d(null,(e=>"Max games supported exceeded: "+n(e))(m)));r(m,l);const p=l+"'s Game",_=E(m,p);o(m,_),"true"===c&&await _.setPractice(),a.send(d({id:_.id,name:p,lobbyData:_.getLobbyData()})),y()}),[G_R_UPDATE_LOBBY+"/:id/:args"]:m(async(e,t)=>{const{id:a,args:n}=e.params,[r]=n.split(","),o=g(a,e,t);if(!o)return;const i=s(o);i?(await i.setMapIndex(r),i.updateLobbyData(),t.send(d({id:i.id,name:i.name,lobbyData:i.getLobbyData()}))):t.send(d(null,l(o)))}),[G_R_JOIN+"/:id/:args"]:m(async(t,a)=>{const{id:s,args:i}=t.params,c=i.indexOf(","),m=i.slice(0,c);let p=i.slice(c+1);const _=g(s,t,a);if(!_)return;if(p.length>10)return void a.send(d(null,"Username too long."));p=e(p||"");const h=(e=>u().reduce((t,a)=>a.id===e?a:t,null))(m);h?(o(_,h),r(_,p),n(_),await h.join(_)?(a.send(d({id:h.id,name:h.name,lobbyData:h.getLobbyData()})),y()):a.send(d(null,"Cannot join."))):a.send(d(null,l(_)))}),[G_R_LEAVE+"/:id"]:m((e,t)=>{const{id:a}=e.params,r=g(a,e,t);if(!r)return;const o=s(r);o?(n(r),i(r),o.leave(r),t.send(d(o.id)),y()):t.send(d(null,l(r)))}),[G_R_START+"/:id/:mapIndex"]:m(async(e,t)=>{const{id:a,mapIndex:r}=e.params,o=g(a,e,t);if(!o)return;const i=s(o);i?i.canStart()?(n(o),t.send(d(!0)),await i.setMapIndex(+r),await i.start(),y()):t.send(d(null,"Cannot start yet.")):t.send(d(null,l(o)))}),[G_R_CONFIRM_ACTION+"/:id/:action/:args"]:m((e,t)=>{const{id:a,action:r,args:o}=e.params,i=g(a,e,t);if(!i)return;const c=s(i);c?c.isStarted()?c.confirmAction(r,o,i)?(n(i),t.send(d(!0))):t.send(d(null,"Cannot confirm.")):t.send(d(null,"Game not started.")):t.send(d(null,l(i)))}),io:async e=>{const a=G_randomId(),n=((e,t)=>[e,"","",t])(e,a);t[e.id]=n,e.on("disconnect",m(()=>{(e=>{const[a,n]=e;n&&n.leave(e),delete t[a]})(n)}));const r=await h();e.emit(G_S_CONNECTED,c({games:p(),maps:r.map(e=>({name:e.name})),id:e.id,key:a}))}};module.exports=_;const h=async()=>await storage.get("maps");let f=0;const G=async()=>{if(0===f){const e=await h();f=e.length}return f},E=(e,t)=>{let r,s,o,l,d=[e],m=0,u=!1,p=!1,g=null,_=1,f=Math.round(100/G_FRAME_MS),E=Math.round(100/G_FRAME_MS),w=0,R=0,b=25/G_SCALE,I=175,v=0,L=null,P=null;const x=["blue","red","green","yellow"],O=()=>{try{let e=+new Date;s=e-r,r=e,G_simulate(g,{startTime:m,nowDt:s,now:r});let{projectiles:t}=g;if(0===t.length)return void C();w++,w>=f&&(((e,t)=>{const a=A(t);J.emitAll(G_S_BROADCAST,c({i:e,timestamp:r-m,dynamicGameData:a}))})(_++,g),w=0),R++,R>=E&&(R=0,T(L,r-m,g))}catch(e){console.error("error running simulation",e),C()}},F=()=>{m=r=+new Date,s=0,J.emitAll(G_S_START_SIMULATION,c(g)),l=setTimeout(C,g.maxRoundLength),o=setInterval(O,G_FRAME_MS)},C=()=>{try{if(u){const e=A(g);J.emitAll(G_S_STOP_SIMULATION,c({i:-1,timestamp:r-m,dynamicGameData:e})),T(L,r-m,g),clearInterval(o),o=-1,clearTimeout(l),l=-1,g.projectiles.forEach(e=>{delete g.entMap[e]}),g.projectiles=[],g.collisions=[];const t=k();t?(J.finished=!0,J.finish(t)):(g.players.forEach(e=>{const t=G_getEntityFromEntMap(e,g);t.ready=!1,t.funds+=10}),B(),M(L,g))}}catch(e){console.error("Error stopping game",e.stack)}},j=()=>g.players.reduce((e,t)=>{const a=G_getEntityFromEntMap(t,g);return e&&(!!a.dead||a.ready)},!0),k=()=>{if(p)return!1;let e=[];for(let t=0;t<g.players.length;t++){const a=G_getEntityFromEntMap(g.players[t],g);a.dead||e.push(a)}return 0===e.length?"draw":1===e.length&&e[0].id},U=()=>{J.emitAll(G_S_LOBBY_DATA,c(J.getLobbyData()))},B=()=>{J.emitAll(G_S_GAME_METADATA,c(J.getGameMetadata()))},J={id:a(e),name:t,getPlayers:()=>d.map(e=>({id:a(e),userName:n(e)})),getLobbyData:()=>({mapIndex:v,ownerId:a(e),players:J.getPlayers()}),getGameMetadata:()=>({playersNotReady:g.players.map(e=>G_getEntityFromEntMap(e,g)).filter(e=>!e.dead&&!e.ready).map(e=>({playerName:e.name,color:e.color})),timer:30}),updateLobbyData:U,updateGameMetadata:B,join:async e=>u||p?(console.error("Cannot join"),!1):d.length<4&&(d.push(e),U(),!0),leave(e){for(let t=0;t<d.length;t++){const n=d[t];if(n===e){if(d.splice(t,1),i(n),u){const e=G_getEntityFromEntMap(a(n),g);return 0===d.length?J.stop():e.dead||(e.dead=!0),k()?J.stop():j()&&setTimeout(()=>{try{F()}catch(e){console.error("Error starting",e.stack)}},500),!0}return 0===t?J.stop():U(),!0}}return!1},async start(){u=!0;const e=await h();g=((e,r)=>{let s=(e=>{let t=e.length;e=[...e];const a=[];for(let n=0;n<t;n++){const t=Math.floor(Math.random()*e.length);a.push(e[t]),e.splice(t,1)}return a})(e);P=r;const{width:o,height:i,playerLocations:l}=P,c={name:t,mapName:P.name,width:o,height:i,mapIndex:v,entMap:{},players:[],planets:[],resources:[],projectiles:[],collisions:[],fields:[],result:!1,baseFundsPerRound:10,maxRoundLength:P.maxRoundLength};for(let e=0;e<s.length;e++){const t=s[e],{x:r,y:o,r:i}=l[e],d=G_getRandomLocInCircle(r,o,i);let m={};for(let e in G_actions)m[G_actions[e][0]]=e<=1?99:0;const u={id:a(t),name:n(t),funds:I,actions:m,ready:!1,dead:!1,hp:1,color:x[e],r:b,...d,target:[d.x,d.y]};c.entMap[u.id]=u,c.players.push(u.id)}return G_createEntities(c,P,{}),c})(d,e[v]),g.isPractice=p,L=S(g),M(L,g),J.emitAll(G_S_START,c({startTime:m,gameData:g})),B()},stop(){C(),J.emitAll(G_S_STOP,c("The game was stopped.")),d.forEach(e=>{i(e)}),y()},finish(e){g.result=e,L.result=e,J.emitAll(G_S_FINISHED,c({gameData:g,replay:L})),d.forEach(e=>{i(e)}),y(),p||N(L)},setPractice(){p=!0,I=1e5},async setMapIndex(e){const t=await G();e>=0&&e<t&&(v=e)},confirmAction(e,t,n){const r=G_getEntityFromEntMap(a(n),g);if(!r||r.dead)return console.error("No player exists in game or player is dead.",a(n)),!1;if(r.ready)return console.error("Player has already confirmed an action.",a(n)),!1;const[s,o,i]=t.split(","),l=G_getNormalizedVec([s-r.x,o-r.y]),c=G_SPEEDS[i]&&G_SPEEDS[i][0]||G_SPEEDS.normal[0],d=((e,t,a)=>{const n=G_getActionCost(e)+G_getSpeedCost(t);return G_getEntityFromEntMap(a,g).funds>n&&n})(e,i,a(n));if(!1===d)return!1;const m={action:e,speed:c,vec:l,target:[s,o],cost:d};return D(L,r,m),G_applyAction(g,r,m),r.ready=!0,j()&&setTimeout(()=>{try{F()}catch(e){console.error("Error starting",e.stack)}},500),B(),!0},canStart:()=>!!p||d.length>1&&d.length<=4&&!u,isPractice:()=>p,isStarted:()=>u,getReplay:()=>L,emitAll(e,t){d.forEach(a=>{const[n]=a;n.emit(e,t)})}};return J},S=e=>{const t={version:2};return t.id=G_randomId(),t.date=+new Date,t.name=e.name,t.mapName=e.mapName,t.initialGameData=JSON.parse(JSON.stringify(e)),t.rounds=[],t.result=null,t},A=e=>{const t={};return e.players.forEach(a=>{t[a]=w(G_getEntityFromEntMap(a,e))}),e.projectiles.forEach(a=>{t[a]=w(G_getEntityFromEntMap(a,e))}),{partialEntMap:t,collisions:e.collisions.map(R),fields:e.fields.slice(),planets:e.planets.slice(),players:e.players.slice(),resources:e.resources.slice(),projectiles:e.projectiles.slice()}},M=(e,t)=>{e.rounds.push({roundNumber:e.rounds.length,dynamicGameData:A(t),actions:{},snapshots:[]})},D=(e,t,{action:a,speed:n,vec:r,cost:s,target:o})=>{e.rounds[e.rounds.length-1].actions[t.id]={action:a,speed:n,vec:r,cost:s,target:o}},T=(e,t,a)=>{e.rounds[e.rounds.length-1].snapshots.push({timestamp:t,dynamicGameData:A(a)})},N=async e=>{try{let t=await storage.get("replays");t||(t=[]),t.length>10&&(t=t.slice(-9)),t.push(e),await storage.set("replays",t)}catch(e){console.error("error saving replay",e.stack)}},w=e=>{switch(G_getEntityType(e)){case G_entity.player:return n=e,{...n,actions:{...n.actions}};case G_entity.projectile:case G_entity.planet:return t=e,{...t,meta:{...t.meta}};default:return a=e,{...a}}var t,a,n},R=e=>{const[t,a,n,r]=e||[];return[t,a,n,r]}})();